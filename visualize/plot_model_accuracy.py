#!/usr/bin/env python3
"""
Plot model accuracy from model evaluation tables in visualization JSON files.

This script analyzes JSON files generated by the visualize.py script, extracts model
evaluation table data from each sample, normalizes the order values, and creates a
scatter plot showing accuracy vs normalized order across all samples.

The script excludes any data points where the order value cannot be parsed as a number
(e.g., if the order is a non-numeric string without any digits). Only data points
with valid numeric order values are included in the plot.
"""

import json
import argparse
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path
import re
import seaborn as sns

def convert_to_numeric(order):
    """Convert an order value to a numeric value."""
    if isinstance(order, (int, float)):
        return float(order)
    if isinstance(order, str):
        if order.isdigit():
            return float(order)
        match = re.search(r'(\d+)', order)
        return float(match.group(1)) if match else float('inf')
    return float('inf')

def normalize_orders(orders):
    """Normalize a list of order values to the range [0, 1].
    
    Raises:
        ValueError: If any order value is infinity or cannot be converted to a finite number.
    """
    numeric_orders = [convert_to_numeric(order) for order in orders]
    
    # Check for infinity values
    if any(o == float('inf') for o in numeric_orders):
        raise ValueError("Cannot normalize orders containing infinity values")
    
    # Handle special cases
    if len(set(numeric_orders)) <= 1:
        return [0.5] * len(numeric_orders)
        
    min_order = min(numeric_orders)
    max_order = max(numeric_orders)
    
    if min_order == max_order:
        return [0.5] * len(numeric_orders)
    
    return [(o - min_order) / (max_order - min_order) for o in numeric_orders]

def extract_model_accuracy_data(json_file):
    """Extract model accuracy data from the JSON file."""
    with open(json_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    all_data = []
    total_filtered = 0
    
    for sample_idx, sample in enumerate(data['samples']):
        if 'model_evaluation_table' not in sample:
            continue
        
        model_table = sample['model_evaluation_table']
        valid_rows = [
            (row['order'], float(row['accuracy']))
            for row in model_table
            if not row.get('has_error', False)
            and row.get('order') is not None
            and row.get('accuracy') is not None
        ]
        
        if not valid_rows:
            continue
            
        orders, accuracies = zip(*valid_rows)
        numeric_orders = [convert_to_numeric(order) for order in orders]
        
        # Filter out invalid orders
        valid_data = [
            (order, accuracy)
            for order, accuracy, num_order in zip(orders, accuracies, numeric_orders)
            if num_order != float('inf')
        ]
        
        if not valid_data:
            continue
            
        filtered_orders, filtered_accuracies = zip(*valid_data)
        total_filtered += len(orders) - len(filtered_orders)
        
        normalized_orders = normalize_orders(filtered_orders)
        all_data.extend((norm_order, accuracy, sample_idx)
                       for norm_order, accuracy in zip(normalized_orders, filtered_accuracies))
    
    return all_data, total_filtered

def plot_model_accuracy(data, output_file=None, title=None):
    """Create a scatter plot of model accuracy vs normalized order."""
    plt.figure(figsize=(12, 8))
    
    norm_orders, accuracies, sample_indices = zip(*data)
    unique_samples = set(sample_indices)
    colors = plt.cm.viridis(np.linspace(0, 1, len(unique_samples)))
    
    # Plot individual points
    for i, sample_idx in enumerate(unique_samples):
        points = [(o, a) for o, a, s in data if s == sample_idx]
        if points:
            sample_orders, sample_accuracies = zip(*points)
            plt.scatter(sample_orders, sample_accuracies, 
                       color=colors[i], alpha=0.7, label=f"Sample {sample_idx}")
    
    # Add trend line
    x = np.array(norm_orders)
    y = np.array(accuracies)
    
    # Try both linear and quadratic fits
    linear_coeffs = np.polyfit(x, y, 1)
    quadratic_coeffs = np.polyfit(x, y, 2)
    
    # Calculate R² for both fits
    linear_pred = np.polyval(linear_coeffs, x)
    quadratic_pred = np.polyval(quadratic_coeffs, x)
    
    linear_r2 = 1 - (np.sum((y - linear_pred) ** 2) / np.sum((y - np.mean(y)) ** 2))
    quadratic_r2 = 1 - (np.sum((y - quadratic_pred) ** 2) / np.sum((y - np.mean(y)) ** 2))
    
    # Choose the better fit based on R²
    if quadratic_r2 > linear_r2:
        coeffs = quadratic_coeffs
        r2 = quadratic_r2
        fit_type = "Quadratic"
    else:
        coeffs = linear_coeffs
        r2 = linear_r2
        fit_type = "Linear"
    
    # Plot the trend line
    x_fit = np.linspace(min(x), max(x), 100)
    y_fit = np.polyval(coeffs, x_fit)
    plt.plot(x_fit, y_fit, 'r-', linewidth=2, 
             label=f"{fit_type} Fit (R² = {r2:.3f})")
    
    plt.axhline(y=100, color='r', linestyle='--', alpha=0.3)
    plt.xlabel('Normalized Model Order')
    plt.ylabel('Accuracy (%)')
    plt.title(title or 'Model Accuracy vs Normalized Order Across Samples')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.ylim(50, 90)
    
    # if len(unique_samples) <= 20:
    #     plt.legend(loc='lower right')
    # else:
    #     plt.legend(loc='lower right', bbox_to_anchor=(1.0, 0.0))
    
    plt.tight_layout()
    
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Plot saved to: {output_file}")
    else:
        plt.show()

def plot_model_accuracy_with_ci(data, output_file=None, title=None):
    """Create a scatter plot with mean line and confidence intervals using seaborn."""
    plt.figure(figsize=(12, 8))
    
    # Convert data to DataFrame format for seaborn
    norm_orders, accuracies, sample_indices = zip(*data)
    import pandas as pd
    df = pd.DataFrame({
        'Normalized Order': norm_orders,
        'Accuracy': accuracies,
        'Sample': sample_indices
    })
    
    # Create scatter plot with mean line and confidence intervals
    sns.lineplot(data=df, x='Normalized Order', y='Accuracy', 
                ci=95,  # 95% confidence interval
                estimator='mean',
                label='Mean with 95% CI')
    
    # Add individual points
    # sns.scatterplot(data=df, x='Normalized Order', y='Accuracy',
    #                hue='Sample', palette='viridis', alpha=0.7,
    #                legend=False)
    
    plt.axhline(y=100, color='r', linestyle='--', alpha=0.3)
    plt.xlabel('Normalized Model Order')
    plt.ylabel('Accuracy (%)')
    plt.title(title or 'Model Accuracy vs Normalized Order with Confidence Intervals')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.ylim(-5, 105)
    
    plt.tight_layout()
    
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Plot saved to: {output_file}")
    else:
        plt.show()

def main():
    parser = argparse.ArgumentParser(description='Plot model accuracy from visualization JSON files')
    parser.add_argument('--input', type=str, help='Path to the visualization JSON file')
    parser.add_argument('--output', '-o', type=str, default=None, 
                        help='Base path to save the plots (if not specified, show the plots)')
    parser.add_argument('--title', '-t', type=str, default=None,
                        help='Custom title for the plots')
    parser.add_argument('--plot-type', choices=['trend', 'ci', 'both'], default='both',
                        help='Type of plot to generate: trend (with fitted line), ci (with confidence intervals), or both')
    
    args = parser.parse_args()
    
    if not Path(args.input).exists():
        print(f"Error: File '{args.input}' not found")
        return 1
    
    print(f"Extracting model accuracy data from: {args.input}")
    data, filtered_count = extract_model_accuracy_data(args.input)
    
    if not data:
        print("No model evaluation data found in the JSON file")
        return 1
    
    print(f"Plotting {len(data)} data points from {len(set(d[2] for d in data))} samples")
    if filtered_count > 0:
        print(f"Filtered out {filtered_count} data points with non-numeric order values")
    
    input_stem = Path(args.input).stem
    
    if args.plot_type in ['trend', 'both']:
        trend_output = args.output or f"{input_stem}_trend_plot.png"
        print("\nGenerating trend plot...")
        plot_model_accuracy(data, trend_output, args.title)
    
    if args.plot_type in ['ci', 'both']:
        ci_output = args.output or f"{input_stem}_ci_plot.png"
        print("\nGenerating confidence interval plot...")
        plot_model_accuracy_with_ci(data, ci_output, args.title)
    
    return 0

if __name__ == "__main__":
    exit(main()) 