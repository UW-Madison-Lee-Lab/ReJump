#!/usr/bin/env python3
"""
Compare model accuracy/MSE from multiple visualization JSON files.

This script analyzes multiple JSON files generated by the visualize.py script,
extracts model evaluation data from each file, and creates comparative plots 
showing the fitted regression lines for accuracy (classification) or MSE (regression)
across all input files.

The script supports both classification and regression data types:
- For classification: compares accuracy values (higher is better)
- For regression: compares MSE values (lower is better)

Unlike plot_model_accuracy.py, this script only displays the regression lines
for easier comparison between multiple models/datasets without the scatter points.
"""

import json
import argparse
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path
import re
import seaborn as sns
import math
import pandas as pd
from sklearn.metrics import r2_score
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.pipeline import make_pipeline
import os

# Import functions from plot_model_accuracy.py
from plot_model_accuracy import (
    extract_model_accuracy_data,
    extract_model_mse_data,
    clear_existing_plots
)

# Define darker colors for 2-dataset comparison
dark_orange = '#D95F02' # A darker orange
dark_blue = '#1F78B4'  # A reasonably dark blue (already used by tab10, but let's be explicit)

def compare_plot_model_accuracy(data_list, labels, output_file=None, title=None, y_limits=(40, 100), show_ci=True, is_unnormalized=False):
    """Create a comparison plot of model accuracy regression lines for multiple datasets."""
    clear_existing_plots()
    
    num_datasets = len(data_list)
    if num_datasets == 2:
        # Use defined dark orange and dark blue for exactly two datasets (swapped order)
        colors = [dark_orange, dark_blue]
    else:
        # Use default palette for more than 2 datasets
        colors = plt.cm.tab10(np.linspace(0, 1, num_datasets))
    
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.grid(True, linestyle='--', alpha=0.6)
    
    # Store coordinates for the first two datasets for overlap detection
    coords_list = [None] * num_datasets
    valid_data_exists = [False] * num_datasets

    # --- Loop 1: Plot Regression Lines and Collect Coordinates --- 
    for i, (data, label) in enumerate(zip(data_list, labels)):
        if not data:
            print(f"Warning: No data available for dataset '{label}'")
            continue
        
        # Extract and validate data for this dataset
        orders, values, _ = zip(*data)
        x = np.array(orders)
        y = np.array(values)
        valid_mask = ~np.isnan(x) & ~np.isnan(y) & np.isfinite(x) & np.isfinite(y)
        x_valid = x[valid_mask]
        y_valid = y[valid_mask]
        
        if len(x_valid) < 3:
            print(f"Warning: Not enough valid data points for fitting in dataset '{label}' ({len(x_valid)} points)")
            continue

        valid_data_exists[i] = True
        # Store coordinates only if we have exactly two datasets
        if num_datasets == 2:
             coords_list[i] = (x_valid, y_valid)

        try:
            # Fit and plot regression line + CI
            df_fit = pd.DataFrame({'x': x_valid, 'y': y_valid})
            model = make_pipeline(PolynomialFeatures(2), LinearRegression())
            model.fit(x_valid.reshape(-1, 1), y_valid)
            r2 = r2_score(y_valid, model.predict(x_valid.reshape(-1, 1)))
            color = colors[i]
            
            if show_ci:
                sns.regplot(x='x', y='y', data=df_fit,
                          scatter=False, order=2, ci=95,
                          line_kws={'color': color, 'linewidth': 3},
                          color=color, ax=ax)
                if ax.collections: # Handle CI color
                    ci_collection = ax.collections[-1]
                    ci_collection.set_alpha(0.3)
                    ci_collection.set_facecolor(color)
                line = ax.get_lines()[-1]
                line.set_label(f"{label} (R²={r2:.3f})")
                print(f"Added regression line with 95% CI for '{label}' with R²={r2:.3f}")
            else:
                x_smooth = np.linspace(min(x_valid), max(x_valid), 100)
                y_pred_smooth = model.predict(x_smooth.reshape(-1, 1))
                ax.plot(x_smooth, y_pred_smooth, '-', color=color, linewidth=3, 
                         label=f"{label} (R²={r2:.3f})")
                print(f"Added regression line for '{label}' with R²={r2:.3f}")
                
        except Exception as e:
            print(f"Error fitting/plotting regression for dataset '{label}': {e}")

    # --- Plot Scatter Points (Only if num_datasets == 2) --- 
    if num_datasets == 2 and all(valid_data_exists):
        x0, y0 = coords_list[0]
        x1, y1 = coords_list[1]
        
        set0 = set(zip(x0, y0))
        set1 = set(zip(x1, y1))
        
        overlap = set0.intersection(set1)
        unique0 = set0 - overlap
        unique1 = set1 - overlap
        
        # Unzip coordinates for plotting
        x_overlap, y_overlap = zip(*overlap) if overlap else ([], [])
        x_unique0, y_unique0 = zip(*unique0) if unique0 else ([], [])
        x_unique1, y_unique1 = zip(*unique1) if unique1 else ([], [])
        
        # Plot unique points
        ax.scatter(x_unique0, y_unique0, color=colors[0], alpha=0.6, s=25, label='_nolegend_') # Orange unique
        ax.scatter(x_unique1, y_unique1, color=colors[1], alpha=0.6, s=25, label='_nolegend_') # Blue unique
        
        # Plot overlapping points
        if overlap:
             ax.scatter(x_overlap, y_overlap, color=colors[0], alpha=0.6, s=25, label='_nolegend_') # Orange dot
             ax.scatter(x_overlap, y_overlap, facecolors='none', edgecolors=colors[1], 
                        linewidths=1.0, s=50, label='Overlap') # Blue circle

    # --- Final Plot Configuration --- 
    plt.axhline(y=100, color='r', linestyle='--', alpha=0.3)
    x_label = "Original Model Order" if is_unnormalized else "Normalized Model Order"
    plt.xlabel(x_label, fontsize=12)
    plt.ylabel('Accuracy (%)', fontsize=12)
    plot_title = title or ('Model Accuracy Comparison (Unnormalized Order)' if is_unnormalized else 'Model Accuracy Comparison')
    plt.title(plot_title, fontsize=14, fontweight='bold')
    plt.ylim(y_limits[0], y_limits[1])
    
    # Adjust legend to include 'Overlap' if it exists
    handles, legend_labels = ax.get_legend_handles_labels()
    if any(lbl == 'Overlap' for lbl in legend_labels):
         # Keep existing handles/labels, potentially add overlap
         pass 
    elif overlap: # Add overlap legend manually if scatter was plotted but not labeled somehow
        from matplotlib.lines import Line2D
        overlap_handle = Line2D([0], [0], marker='o', color='w', label='Overlap',
                              markerfacecolor=colors[0], markeredgecolor=colors[1], 
                              markersize=8, markeredgewidth=1)
        handles.append(overlap_handle)
        legend_labels.append('Overlap')
        
    # Only add legend if there are labels
    if handles:
        ax.legend(handles=handles, labels=legend_labels, loc='lower right', fontsize=10, framealpha=0.9, edgecolor='gray')
    
    plt.tight_layout()
    if output_file:
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Comparison plot saved to: {output_file}")
    else:
        plt.show()

def compare_plot_model_mse(data_list, labels, output_file=None, title=None, y_limits=(1e-2, 1), show_ci=True, is_unnormalized=False):
    """Create a comparison plot of model MSE regression lines for multiple datasets."""
    clear_existing_plots()
    
    num_datasets = len(data_list)
    if num_datasets == 2:
        colors = [dark_orange, dark_blue]
    else:
        colors = plt.cm.tab10(np.linspace(0, 1, num_datasets))
    
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.grid(True, linestyle='--', alpha=0.6)
    
    coords_list = [None] * num_datasets
    valid_data_exists = [False] * num_datasets
    
    # Determine if log scale is needed based on *all* data points across datasets
    all_mse_values_flat = []
    for data in data_list:
        if data:
            _, mse_values, _ = zip(*data)
            all_mse_values_flat.extend(m for m in mse_values if m is not None and np.isfinite(m))
    use_log_scale = all_mse_values_flat and not np.any(np.array(all_mse_values_flat) <= 0)

    # --- Loop 1: Plot Regression Lines and Collect Coordinates --- 
    for i, (data, label) in enumerate(zip(data_list, labels)):
        if not data:
            print(f"Warning: No data available for dataset '{label}'")
            continue
            
        orders, values, _ = zip(*data)
        x = np.array(orders)
        y = np.array(values)
        valid_mask = ~np.isnan(x) & ~np.isnan(y) & np.isfinite(x) & np.isfinite(y)
        x_valid = x[valid_mask]
        y_valid = y[valid_mask]
        
        if len(x_valid) < 3:
            print(f"Warning: Not enough valid data points for fitting in dataset '{label}' ({len(x_valid)} points)")
            continue
            
        valid_data_exists[i] = True
        if num_datasets == 2:
             coords_list[i] = (x_valid, y_valid)

        try:
            color = colors[i]
            r2_label_suffix = ""
            
            # Handle log scale fitting
            if use_log_scale and not np.any(y_valid <= 0):
                log_y_valid = np.log(y_valid)
                df_fit = pd.DataFrame({'x': x_valid, 'y': log_y_valid})
                model = make_pipeline(PolynomialFeatures(2), LinearRegression())
                model.fit(x_valid.reshape(-1, 1), log_y_valid)
                r2 = r2_score(log_y_valid, model.predict(x_valid.reshape(-1, 1)))
                r2_label_suffix = ", log scale"
                
                if show_ci:
                    sns.regplot(x='x', y='y', data=df_fit,
                              scatter=False, order=2, ci=95,
                              line_kws={'color': color, 'linewidth': 3},
                              color=color, ax=ax)
                    # CI color handled later for log scale
                    print(f"Added log-scale regression line prep for '{label}' with R²={r2:.3f}")
                else:
                     x_smooth = np.linspace(min(x_valid), max(x_valid), 100)
                     y_pred_smooth_log = model.predict(x_smooth.reshape(-1, 1))
                     ax.plot(x_smooth, np.exp(y_pred_smooth_log), '-', color=color, linewidth=3, 
                              label=f"{label} (R²={r2:.3f}{r2_label_suffix})")
                     print(f"Added log-scale regression line for '{label}' with R²={r2:.3f}")
            else:
                # Linear scale fitting
                df_fit = pd.DataFrame({'x': x_valid, 'y': y_valid})
                model = make_pipeline(PolynomialFeatures(2), LinearRegression())
                model.fit(x_valid.reshape(-1, 1), y_valid)
                r2 = r2_score(y_valid, model.predict(x_valid.reshape(-1, 1)))
                
                if show_ci:
                    sns.regplot(x='x', y='y', data=df_fit,
                              scatter=False, order=2, ci=95,
                              line_kws={'color': color, 'linewidth': 3},
                              color=color, ax=ax)
                    if ax.collections: # Handle CI color
                        ci_collection = ax.collections[-1]
                        ci_collection.set_alpha(0.3)
                        ci_collection.set_facecolor(color)
                    line = ax.get_lines()[-1]
                    line.set_label(f"{label} (R²={r2:.3f}{r2_label_suffix})")
                    print(f"Added regression line with 95% CI for '{label}' with R²={r2:.3f}")
                else:
                    x_smooth = np.linspace(min(x_valid), max(x_valid), 100)
                    y_pred_smooth = model.predict(x_smooth.reshape(-1, 1))
                    ax.plot(x_smooth, y_pred_smooth, '-', color=color, linewidth=3, 
                             label=f"{label} (R²={r2:.3f}{r2_label_suffix})")
                    print(f"Added regression line for '{label}' with R²={r2:.3f}")

        except Exception as e:
            print(f"Error fitting/plotting regression for dataset '{label}': {e}")
            
    # Set log scale *after* all plotting if needed
    if use_log_scale:
        ax.set_yscale('log')
        # Adjust CI colors and labels for log scale plots if CI was shown
        if show_ci:
            lines = ax.get_lines()
            collections = ax.collections
            line_index = 0
            col_index = 0
            for i in range(num_datasets):
                 if valid_data_exists[i]:
                     current_line = lines[line_index]
                     current_label = current_line.get_label()
                     if "(log scale)" not in current_label: # Check if label needs update
                         current_line.set_label(f"{labels[i]} (R²=..., log scale)") # Update label format; R2 was calculated on log
                     if col_index < len(collections):
                         collections[col_index].set_alpha(0.3)
                         collections[col_index].set_facecolor(colors[i])
                         col_index += 1
                     line_index += 1
    else:
         ax.set_yscale('linear')

    # --- Plot Scatter Points (Only if num_datasets == 2) ---
    if num_datasets == 2 and all(valid_data_exists):
        x0, y0 = coords_list[0]
        x1, y1 = coords_list[1]
        
        set0 = set(zip(x0, y0))
        set1 = set(zip(x1, y1))
        
        overlap = set0.intersection(set1)
        unique0 = set0 - overlap
        unique1 = set1 - overlap
        
        x_overlap, y_overlap = zip(*overlap) if overlap else ([], [])
        x_unique0, y_unique0 = zip(*unique0) if unique0 else ([], [])
        x_unique1, y_unique1 = zip(*unique1) if unique1 else ([], [])
        
        ax.scatter(x_unique0, y_unique0, color=colors[0], alpha=0.6, s=25, label='_nolegend_') 
        ax.scatter(x_unique1, y_unique1, color=colors[1], alpha=0.6, s=25, label='_nolegend_') 
        
        if overlap:
            ax.scatter(x_overlap, y_overlap, color=colors[0], alpha=0.6, s=25, label='_nolegend_')
            ax.scatter(x_overlap, y_overlap, facecolors='none', edgecolors=colors[1], 
                       linewidths=1.0, s=50, label='Overlap')

    # --- Final Plot Configuration --- 
    x_label = "Original Model Order" if is_unnormalized else "Normalized Model Order"
    plt.xlabel(x_label, fontsize=12)
    plt.ylabel('Mean Squared Error (MSE)', fontsize=12)
    plot_title = title or ('Model MSE Comparison (Unnormalized Order)' if is_unnormalized else 'Model MSE Comparison')
    plt.title(plot_title, fontsize=14, fontweight='bold')
    
    if y_limits[0] is not None or y_limits[1] is not None:
        ymin = y_limits[0] if y_limits[0] is not None else ax.get_ylim()[0]
        ymax = y_limits[1] if y_limits[1] is not None else ax.get_ylim()[1]
        # Ensure ymin is positive for log scale if needed
        if use_log_scale and ymin <= 0:
             current_ymin, _ = ax.get_ylim()
             ymin = min(m for m in all_mse_values_flat if m > 0) * 0.5 if any(m > 0 for m in all_mse_values_flat) else 1e-5 # Auto-adjust if y_min is invalid for log
             print(f"Warning: y_min adjusted to {ymin} for log scale.")
        ax.set_ylim(ymin, ymax)

    handles, legend_labels = ax.get_legend_handles_labels()
    if any(lbl == 'Overlap' for lbl in legend_labels):
         pass 
    elif overlap: 
        from matplotlib.lines import Line2D
        overlap_handle = Line2D([0], [0], marker='o', color='w', label='Overlap',
                              markerfacecolor=colors[0], markeredgecolor=colors[1], 
                              markersize=8, markeredgewidth=1)
        handles.append(overlap_handle)
        legend_labels.append('Overlap')
        
    if handles:
        ax.legend(handles=handles, labels=legend_labels, loc='upper right', fontsize=10, framealpha=0.9, edgecolor='gray')
    
    plt.tight_layout()
    if output_file:
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Comparison plot saved to: {output_file}")
    else:
        plt.show()

def main():
    parser = argparse.ArgumentParser(description='Compare model accuracy/MSE from multiple visualization JSON files')
    parser.add_argument('--input', type=str, nargs='+', required=True, 
                        help='Paths to the visualization JSON files')
    parser.add_argument('--labels', type=str, nargs='+', 
                        help='Labels for each input file (must match number of input files)')
    parser.add_argument('--output', '-o', type=str, default=None, 
                        help='Path to save the comparison plot directory')
    parser.add_argument('--title', '-t', type=str, default=None,
                        help='Custom title for the comparison plot')
    parser.add_argument('--data_type', choices=['classification', 'regression'], default='classification',
                        help='Type of data to analyze: classification (accuracy) or regression (MSE)')
    parser.add_argument('--y_min', type=float, default=None,
                        help='Minimum value for y-axis')
    parser.add_argument('--y_max', type=float, default=None,
                        help='Maximum value for y-axis')
    parser.add_argument('--no_ci', action='store_true',
                        help='Disable 95% confidence interval display')
    parser.add_argument('--unnormalized', action='store_true',
                        help='Plot using unnormalized order values')
    
    args = parser.parse_args()
    
    # Validate input files
    input_paths = [Path(path) for path in args.input]
    for path in input_paths:
        if not path.exists():
            print(f"Error: File '{path}' not found")
            return 1
    
    # Generate default labels if not provided
    if args.labels is None:
        args.labels = [f"Dataset {i+1}" for i in range(len(input_paths))]
    elif len(args.labels) != len(input_paths):
        print(f"Error: Number of labels ({len(args.labels)}) must match number of input files ({len(input_paths)})")
        return 1
    
    # Extract data from all input files
    all_data = []
    all_data_unnormalized = []
    
    for input_path in input_paths:
        print(f"Extracting model data from: {input_path}")
        
        if args.data_type == 'classification':
            data, _, _, _, _, unnormalized_data = extract_model_accuracy_data(str(input_path))
            metric_name = "accuracy"
        else:
            data, _, _, _, _, unnormalized_data = extract_model_mse_data(str(input_path))
            metric_name = "MSE"
        
        if not data:
            print(f"No model evaluation {metric_name} data found in file: {input_path}")
            # Still append an empty list to keep indices aligned
            all_data.append([])
            all_data_unnormalized.append([])
        else:
            print(f"Extracted {len(data)} {metric_name} data points from {input_path}")
            if unnormalized_data:
                print(f"Extracted {len(unnormalized_data)} unnormalized {metric_name} data points")
            all_data.append(data)
            all_data_unnormalized.append(unnormalized_data)
    
    # Check if we have data for at least two datasets for comparison
    valid_datasets_indices = [i for i, d in enumerate(all_data) if d] 
    if len(valid_datasets_indices) < 1:
         print("Error: No valid data found in any input file.")
         return 1
    # Filter labels and data to only include those with valid data
    filtered_labels = [args.labels[i] for i in valid_datasets_indices]
    filtered_all_data = [all_data[i] for i in valid_datasets_indices]
    filtered_all_data_unnormalized = [all_data_unnormalized[i] for i in valid_datasets_indices]


    # Create default output paths
    if args.output is None:
        output_dir = Path("/home/szhang967/liftr/reasoning_analysis/compare_RLMs")
    else:
        output_dir = Path(args.output)
    
    os.makedirs(output_dir, exist_ok=True)
    
    # Generate filename from the (filtered) labels
    label_part = "_vs_".join([label.replace(" ", "_") for label in filtered_labels[:2]])
    if len(filtered_labels) > 2:
        label_part += "_and_more"
    ci_suffix = "" if args.no_ci else "_with_ci"
    normalized_output_filename = f"{args.data_type}_{label_part}_normalized{ci_suffix}.png"
    normalized_output_path = output_dir / normalized_output_filename
    unnormalized_output_filename = f"{args.data_type}_{label_part}_unnormalized{ci_suffix}.png"
    unnormalized_output_path = output_dir / unnormalized_output_filename
    
    # Set y-axis limits
    if args.data_type == 'classification':
        y_min = args.y_min if args.y_min is not None else 40
        y_max = args.y_max if args.y_max is not None else 100
    else:  # regression
        y_min = args.y_min if args.y_min is not None else 1e-2
        y_max = args.y_max if args.y_max is not None else 1
    y_limits = (y_min, y_max)
    
    # Always create both normalized and unnormalized plots using filtered data
    print(f"\nGenerating {args.data_type} comparison plot with normalized order values...")
    if args.data_type == 'classification':
        normalized_title = f"{args.title} (Normalized)" if args.title else "Model Accuracy Comparison (Normalized)"
        compare_plot_model_accuracy(filtered_all_data, filtered_labels, normalized_output_path, 
                                  normalized_title, y_limits, show_ci=not args.no_ci)
        unnormalized_title = f"{args.title} (Unnormalized)" if args.title else "Model Accuracy Comparison (Unnormalized)"
        compare_plot_model_accuracy(filtered_all_data_unnormalized, filtered_labels, unnormalized_output_path, 
                                  unnormalized_title, y_limits, show_ci=not args.no_ci, is_unnormalized=True)
    else:
        normalized_title = f"{args.title} (Normalized)" if args.title else "Model MSE Comparison (Normalized)"
        compare_plot_model_mse(filtered_all_data, filtered_labels, normalized_output_path, 
                              normalized_title, y_limits, show_ci=not args.no_ci)
        unnormalized_title = f"{args.title} (Unnormalized)" if args.title else "Model MSE Comparison (Unnormalized)"
        compare_plot_model_mse(filtered_all_data_unnormalized, filtered_labels, unnormalized_output_path, 
                              unnormalized_title, y_limits, show_ci=not args.no_ci, is_unnormalized=True)
    
    print(f"Saved normalized plot to: {normalized_output_path}")
    print(f"Saved unnormalized plot to: {unnormalized_output_path}")
    
    return 0

if __name__ == "__main__":
    exit(main()) 